/**
 * Web-Chat
 * - The Web-Chat application consists of an HTTP service functioning a central hub for multiple clients chatting by means of __chat rooms__  - Clients can register themselves using unique usernames, addresses, and passwords     + Upon registration, they are endowed with an [Universally unique identifier](https://it.wikipedia.org/wiki/Universally_unique_identifier) (UUID)     + Clients can either be `admin`s or `user`s     + Unlogged clients can chat too, but they have no explicit identity or role     + A logged client can be referenced by means of its username, its address, or its UUID  - Clients can create chat rooms -- thus becoming their __owners__ --, whereas other clients may __join__ -- thus becoming __members__ --, or leave such chat rooms     + Chat rooms can be referenced by means of their name, which is assumed to be unique     + The members of a chat room can see the whole sequence of messages published within that chat room or just a sub-sequence     + The members of a chat room can see the whole set of members of the chat room  - Owners can create their chat rooms with three different access levels:     + __public__ chat rooms can be read and written by anyone, there including unlogged users: membership is unimportant here     + __open__ chat rooms can be read and written only by their members, but any logged user can join them     + conversely, in __private__ chat rooms only the owner can assign memberships  - `admin`s can inspect and manage the list of registered users     - a registered `user` can be removed either by an `admin` or by him/her self  - The list of currently existing chat rooms is publicly available  - Here we consider a _very trivial and **insecure**_ authentication and authorization schema:     * upon registration, clients are assumed to provide an identifier and a password (i.e., their __credentials__), which are stored on the server side         + the server should prevent the same identifier from being registered twice         + clients are assumed to be registered as `user`s         + `admin`s are __hardcoded__ into the provided implementation stub      * when performing an HTTP request, clients are assumed to provide their credentials as a __JSON string__ contained within the __`Authorization`__ header of the request.     The JSON string, should have one of the following forms:         + `{ `__`\"id\"`__`: \"uuid here\", `__`\"password\"`__`: \"password here\" }`         + or `{ `__`\"username\"`__`: \"username here\", `__`\"password\"`__`: \"password here\" }`         + or `{ `__`\"email\"`__`: \"email here\", `__`\"password\"`__`: \"password here\" }`      * when performing an HTTP request, clients are considered __authenticated__ if they credentials match the ones which are stored on the server side      * when performing an HTTP request, clients are considered __authorized__ if they are authenticated _and_ they their role is enabled to perform the requested operation 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.core

import java.io.File
import java.net.URLEncoder

import scala.util.Try

sealed trait ApiReturnWithHeaders {
  def headers: Map[String, String]

  def header(name: String): Option[String] = headers.get(name)

  def getStringHeader(name: String): Option[String] = header(name)

  // workaround: return date time header in string instead of datetime object
  def getDateTimeHeader(name: String): Option[String] = header(name)

  def getIntHeader(name: String): Option[Int] = castedHeader(name, java.lang.Integer.parseInt)

  def getLongHeader(name: String): Option[Long] = castedHeader(name, java.lang.Long.parseLong)

  def getFloatHeader(name: String): Option[Float] = castedHeader(name, java.lang.Float.parseFloat)

  def getDoubleHeader(name: String): Option[Double] = castedHeader(name, java.lang.Double.parseDouble)

  def getBooleanHeader(name: String): Option[Boolean] = castedHeader(name, java.lang.Boolean.parseBoolean)

  private def castedHeader[U](name: String, conversion: String => U): Option[U] = {
    Try {
      header(name).map(conversion)
    }.get
  }
}

sealed case class ApiResponse[T](code: Int, content: T, headers: Map[String, String] = Map.empty)
  extends ApiReturnWithHeaders

sealed case class ApiError[T](code: Int, message: String, responseContent: Option[T], cause: Throwable = null, headers: Map[String, String] = Map.empty)
  extends Throwable(s"($code) $message.${responseContent.map(s => s" Content : $s").getOrElse("")}", cause)
    with ApiReturnWithHeaders

sealed case class ApiMethod(value: String)

object ApiMethods {
  val CONNECT = ApiMethod("CONNECT")
  val DELETE = ApiMethod("DELETE")
  val GET = ApiMethod("GET")
  val HEAD = ApiMethod("HEAD")
  val OPTIONS = ApiMethod("OPTIONS")
  val PATCH = ApiMethod("PATCH")
  val POST = ApiMethod("POST")
  val PUT = ApiMethod("PUT")
  val TRACE = ApiMethod("TRACE")
}

/**
 * This trait needs to be added to any model defined by the api.
 */
trait ApiModel

/**
 * Single trait defining a credential that can be transformed to a paramName / paramValue tupple
 */
sealed trait Credentials {
  def asQueryParam: Option[(String, String)] = None
}

sealed case class BasicCredentials(user: String, password: String) extends Credentials

sealed case class ApiKeyCredentials(key: ApiKeyValue, keyName: String, location: ApiKeyLocation) extends Credentials {
  override def asQueryParam: Option[(String, String)] = location match {
    case ApiKeyLocations.QUERY => Some((keyName, key.value))
    case _ => None
  }
}

sealed case class ApiKeyValue(value: String)

sealed trait ApiKeyLocation

object ApiKeyLocations {

  case object QUERY extends ApiKeyLocation

  case object HEADER extends ApiKeyLocation

}


/**
 * Case class used to unapply numeric values only in pattern matching
 *
 * @param value the string representation of the numeric value
 */
sealed case class NumericValue(value: String) {
  override def toString: String = value
}

object NumericValue {
  def unapply(n: Any): Option[NumericValue] = n match {
    case (_: Int | _: Long | _: Float | _: Double | _: Boolean | _: Byte) => Some(NumericValue(String.valueOf(n)))
    case _ => None
  }
}

/**
 * Used for params being arrays
 */
sealed case class ArrayValues(values: Seq[Any], format: CollectionFormat = CollectionFormats.CSV)

object ArrayValues {
  def apply(values: Option[Seq[Any]], format: CollectionFormat): ArrayValues =
    ArrayValues(values.getOrElse(Seq.empty), format)

  def apply(values: Option[Seq[Any]]): ArrayValues = ArrayValues(values, CollectionFormats.CSV)
}


/**
 * Defines how arrays should be rendered in query strings.
 */
sealed trait CollectionFormat

trait MergedArrayFormat extends CollectionFormat {
  def separator: String
}

object CollectionFormats {

  case object CSV extends MergedArrayFormat {
    override val separator = ","
  }

  case object TSV extends MergedArrayFormat {
    override val separator = "\t"
  }

  case object SSV extends MergedArrayFormat {
    override val separator = " "
  }

  case object PIPES extends MergedArrayFormat {
    override val separator = "|"
  }

  case object MULTI extends CollectionFormat

}

object ParametersMap {

  /**
   * Pimp parameters maps (Map[String, Any]) in order to transform them in a sequence of String -> Any tupples,
   * with valid url-encoding, arrays handling, files preservation, ...
   */
  implicit class ParametersMapImprovements(val m: Map[String, Any]) {

    def asFormattedParamsList: List[(String, Any)] = m.toList.flatMap(formattedParams)

    def asFormattedParams: Map[String, Any] = m.flatMap(formattedParams)

    private def urlEncode(v: Any) = URLEncoder.encode(String.valueOf(v), "utf-8").replaceAll("\\+", "%20")

    private def formattedParams(tuple: (String, Any)): Seq[(String, Any)] = formattedParams(tuple._1, tuple._2)

    private def formattedParams(name: String, value: Any): Seq[(String, Any)] = value match {
      case arr: ArrayValues =>
        arr.format match {
          case CollectionFormats.MULTI => arr.values.flatMap(formattedParams(name, _))
          case format: MergedArrayFormat => Seq((name, arr.values.mkString(format.separator)))
        }
      case None => Seq.empty
      case Some(opt) => formattedParams(name, opt)
      case s: Seq[Any] => formattedParams(name, ArrayValues(s))
      case v: String => Seq((name, urlEncode(v)))
      case NumericValue(v) => Seq((name, urlEncode(v)))
      case f: File => Seq((name, f))
      case m: ApiModel => Seq((name, m))
    }
  }

}
