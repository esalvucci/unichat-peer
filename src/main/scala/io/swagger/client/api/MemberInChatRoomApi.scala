/**
 * Web-Chat
 * - The Web-Chat application consists of an HTTP service functioning a central hub for multiple clients chatting by means of __chat rooms__  - Clients can register themselves using unique usernames, addresses, and passwords     + Upon registration, they are endowed with an [Universally unique identifier](https://it.wikipedia.org/wiki/Universally_unique_identifier) (UUID)     + Clients can either be `admin`s or `user`s     + Unlogged clients can chat too, but they have no explicit identity or role     + A logged client can be referenced by means of its username, its address, or its UUID  - Clients can create chat rooms -- thus becoming their __owners__ --, whereas other clients may __join__ -- thus becoming __members__ --, or leave such chat rooms     + Chat rooms can be referenced by means of their name, which is assumed to be unique     + The members of a chat room can see the whole sequence of messages published within that chat room or just a sub-sequence     + The members of a chat room can see the whole set of members of the chat room  - Owners can create their chat rooms with three different access levels:     + __public__ chat rooms can be read and written by anyone, there including unlogged users: membership is unimportant here     + __open__ chat rooms can be read and written only by their members, but any logged user can join them     + conversely, in __private__ chat rooms only the owner can assign memberships  - `admin`s can inspect and manage the list of registered users     - a registered `user` can be removed either by an `admin` or by him/her self  - The list of currently existing chat rooms is publicly available  - Here we consider a _very trivial and **insecure**_ authentication and authorization schema:     * upon registration, clients are assumed to provide an identifier and a password (i.e., their __credentials__), which are stored on the server side         + the server should prevent the same identifier from being registered twice         + clients are assumed to be registered as `user`s         + `admin`s are __hardcoded__ into the provided implementation stub      * when performing an HTTP request, clients are assumed to provide their credentials as a __JSON string__ contained within the __`Authorization`__ header of the request.     The JSON string, should have one of the following forms:         + `{ `__`\"id\"`__`: \"uuid here\", `__`\"password\"`__`: \"password here\" }`         + or `{ `__`\"username\"`__`: \"username here\", `__`\"password\"`__`: \"password here\" }`         + or `{ `__`\"email\"`__`: \"email here\", `__`\"password\"`__`: \"password here\" }`      * when performing an HTTP request, clients are considered __authenticated__ if they credentials match the ones which are stored on the server side      * when performing an HTTP request, clients are considered __authorized__ if they are authenticated _and_ they their role is enabled to perform the requested operation 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.MemberInChatRoom
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class MemberInChatRoomApi(
  val defBasePath: String = "http://localhost:9000/",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new MemberInChatRoomApiAsyncHelper(client, config)

  /**
   * Add a user to a particular chat room
   * Add a user to a particular chat room. 
   *
   * @param chatRoomName The chat room name 
   * @param body The username to be added.
 (optional)
   * @return List[MemberInChatRoom]
   */
  def addUserInChatRoom(chatRoomName: String, body: Option[MemberInChatRoom] = None): Option[List[MemberInChatRoom]] = {
    val await = Try(Await.result(addUserInChatRoomAsync(chatRoomName, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a user to a particular chat room asynchronously
   * Add a user to a particular chat room. 
   *
   * @param chatRoomName The chat room name 
   * @param body The username to be added.
 (optional)
   * @return Future(List[MemberInChatRoom])
   */
  def addUserInChatRoomAsync(chatRoomName: String, body: Option[MemberInChatRoom] = None): Future[List[MemberInChatRoom]] = {
      helper.addUserInChatRoom(chatRoomName, body)
  }

  /**
   * Delete a particular user of a particular chat room
   * Delete a particular member of a particular chat room. 
   *
   * @param chatRoomName The chat room name 
   * @param username The chat room user&#39;s identifier (i.e. the identifier of the corresponding user) 
   * @return void
   */
  def removeUserFromChatRoom(chatRoomName: String, username: String) = {
    val await = Try(Await.result(removeUserFromChatRoomAsync(chatRoomName, username), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a particular user of a particular chat room asynchronously
   * Delete a particular member of a particular chat room. 
   *
   * @param chatRoomName The chat room name 
   * @param username The chat room user&#39;s identifier (i.e. the identifier of the corresponding user) 
   * @return Future(void)
   */
  def removeUserFromChatRoomAsync(chatRoomName: String, username: String) = {
      helper.removeUserFromChatRoom(chatRoomName, username)
  }

}

class MemberInChatRoomApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def addUserInChatRoom(chatRoomName: String,
    body: Option[MemberInChatRoom] = None
    )(implicit reader: ClientResponseReader[List[MemberInChatRoom]], writer: RequestWriter[Option[MemberInChatRoom]]): Future[List[MemberInChatRoom]] = {
    // create path and map variables
    val path = (addFmt("/rooms/{chatRoomName}/user")
      replaceAll("\\{" + "chatRoomName" + "\\}", chatRoomName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (chatRoomName == null) throw new Exception("Missing required parameter 'chatRoomName' when calling MemberInChatRoomApi->addUserInChatRoom")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def removeUserFromChatRoom(chatRoomName: String,
    username: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/rooms/{chatRoomName}/{username}")
      replaceAll("\\{" + "chatRoomName" + "\\}", chatRoomName.toString)
      replaceAll("\\{" + "username" + "\\}", username.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (chatRoomName == null) throw new Exception("Missing required parameter 'chatRoomName' when calling MemberInChatRoomApi->removeUserFromChatRoom")

    if (username == null) throw new Exception("Missing required parameter 'username' when calling MemberInChatRoomApi->removeUserFromChatRoom")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
